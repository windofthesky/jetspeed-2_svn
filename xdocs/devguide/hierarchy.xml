<?xml version="1.0"?>
<!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
    
    http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<document>
    <properties>
        <title>Jetspeed 2 Security - Hierarchy Management</title>
        <authors>
            <person name="David Le Strat" email="dlestrat@apache.org" />
        </authors>
    </properties>
    <body>
        <section name="Hierarchy Management Overview">
            <p>
                Two hierarchy resolution strategies are supported for authorization decisions:
                <ul>
                    <li>
                        Hierarchy resolution by Generalization: This is the default hierarchy resolution in Jetspeed. If a hierarchy uses a generalization
                        strategy, each role is more general than the previous one. For instance, if a user has the role [roleA.roleB.roleC] then
                        <code>user.getSubject().getPrincipals()</code>
                        returns:
                        <ul>
                            <li>/role/roleA</li>
                            <li>/role/roleA/roleB</li>
                            <li>/role/roleA/roleB/roleC</li>
                        </ul>
                    </li>
                    <li>
                        Hierarchy resolution by Aggregation: If a hierarchy uses a aggregation strategy, the higher role is responsible for a superset of the
                        activities of the lower role. For instance, if the following roles are available:
                        <ul>
                            <li>roleA</li>
                            <li>roleA.roleB</li>
                            <li>roleA.roleB.roleC</li>
                        </ul>
                        If a user has the role [roleA] then,
                        <code>user.getSubject().getPrincipals()</code>
                        returns:
                        <ul>
                            <li>/role/roleA</li>
                            <li>/role/roleA/roleB</li>
                            <li>/role/roleA/roleB/roleC</li>
                        </ul>
                    </li>
                </ul>
            </p>
            <p>
                As described in the
                <a href="atz-spi.html">authorization SPI section</a>
                , the
                <code>SecurityMappingHandler</code>
                is configured with a specific hierarchy strategy for group and role hierarchy management. See the
                <a href="../deployguide/security-config.html#security-spi-atz_xml">authorization SPI configuration</a>
                for a configuration example.
            </p>
        </section>
        <section name="Leveraging Preferences to Manage Hierarchies">
            <p>
                The default hierarchy management implementation resolves the hierarchy strategy by leveraging Jetspeed 2's
                <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/prefs/Preferences.html">java.util.prefs.Preferences</a>
                implementation. The
                <code>Preferences</code>
                implementation provides the underlying structure in Jetspeed to store user attributes, and roles and groups definitions. The
                <code>Preferences</code>
                model provides a hierarchy model that is leveraged to store the base roles and groups hierarchy upon which various resolving strategies can be
                applied (resolution by generalization or aggregation).
            </p>
            <p>
                See Jetspeed 2
                <a href="dev-prefs.html">Preferences implementation section</a>
                for more information.
            </p>
            <subsection name="How does this work?">
                <p>
                    The
                    <code>SecurityMappingHandler</code>
                    implementation resolves the mappings between roles and groups. Let's say that we want to find out the roles mapping to a specific group
                    name. To do so, the
                    <code>SecurityMappingHandler</code>
                    implements a
                    <code>getRolePrincipalsInGroup(String groupFullPathName)</code>
                    method. In this method, the group name is mapped to a specific
                    <code>Preferences</code>
                    node. According to a given hierarchy resolution strategy (see
                    <a href="#Hierarchy_Management_Overview">overview section</a>
                    ), being in [group A] may mean belonging to a set of groups; the HierarchyResolver is used to do so as illustrated below:
                    <source>
                        <![CDATA[
public Set getRolePrincipalsInGroup(String groupFullPathName)
{
   ...
   Preferences preferences = Preferences.userRoot().node(
       GroupPrincipalImpl.getFullPathFromPrincipalName(groupFullPathName));
   String[] fullPaths = groupHierarchyResolver.resolve(preferences);
   ...
}]]>
                    </source>
                    The resulting groups are then used to find all associated roles.
                </p>
                <p>
                    As a result of this implementation, the name of a role principal (<code>Principal</code> 
                    <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/Principal.html#getName()">getName()</a>) 
                    in the security layer should match the full path of that user preferences
                    root in the preferences layer (<code>Preference</code> 
                    <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/prefs/Preferences.html#absolutePath()">absolutePath()</a>; e.g:
                    <code>/role/theRolePrincipal</code>
                    ).
                </p>
                <p>
                    Group and roles hierarchy are stored in the
                    <code>Preferences</code>
                    layer as follow (the output of <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)">
                    exportNode()</a> for <a href="dev-prefs.html">Jetspeed's RBMS Preferences</a> implementation):
                    <source>
                        <![CDATA[
<preferences EXTERNAL_XML_VERSION="1.0">
<root type="user">
<map />
    <node name="group1">
    <map />
        <node name="groupid1.1">
        <map />
	    <node name="groupid1.1.1">
            <map />
            </node>
        </node>
    </node>

    <node name="role1">
    <map />
        <node name="roleid1.1">
        <map />
	    <node name="roleid1.1.1">
            <map />
            </node>
        </node>
    </node>
</root>]]>
                    </source>
                    This structure would define the following group and role hierarchy:
                    <ul>
                        <li>
                            <code>/group1/groupid1.1/groupid1.1.1</code>
                        </li>
                        <li>
                            <code>/role1/roleid1.1/roleid1.1.1</code>
                        </li>
                    </ul>
                    Additionally, in this model, the
                    <code>map</code>
                    element can define groups or roles custom properties. For instance, a role could have a rule custom property (or a pointer to a rule) that
                    allow rule based role definition tied to some rule engine (Drools for instance) and is validated when the isInRole method is invoked. For
                    groups, a portal could use group to describe organization and have custom property such as address, city, etc. associated with the
                    organization/group.
                </p>
            </subsection>
        </section>
    </body>
</document>
