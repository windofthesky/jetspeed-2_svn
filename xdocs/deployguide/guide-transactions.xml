<?xml version="1.0"?>
<!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
    
    http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<document>
    <properties>
        <title>Jetspeed 2 Transactions</title>
        <subtitle>Guide to Jetspeed Transactions</subtitle>
        <authors>
            <person name="David Sean Taylor" email="taylor@apache.org" />
        </authors>
    </properties>
    <body>
    	<section name="Jetspeed Transactions Configuration">
    		<p>All Jetspeed components that use the database are transactional. This guide helps you learn about how Jetspeed components are 
    		wired together in the context of Spring transactions. When deploying Jetspeed, you may need to modify some of the componnents that
    		are transactional. This guide will help you understand how to configure transactional beans (services) in Jetspeed.</p>
	        <subsection name="Transactions in Spring">
	            <p>
	            Transactions allow you to group several operations into a single unit of work that either fully happens or fully doesn't happen.
	            Jetspeed leverages the Spring Framework to make its components transactional. The Spring Framework provides the transaction management
	            required to execute transactions across two or more Jetspeed components. Jetspeed transactions are configured as declarative transactions.
	            Jetspeed currently does not make use of programmatic transactions. The Spring Framework provides the declarative transaction management
	             through Spring's AOP framework. Spring provides three ways to declare transactional boundaries in the spring configuration.
  				<ol>
  					<li>Spring Transactional Interceptors, Bean Wrapping</li>
  					<li>XML declared transactions</li>
  					<li>Annotations</li>
  				</ol>  				            
				Jetspeed uses the original Spring transactional support (1): wrapping Jetspeed components with transactional interceptors.
				When configuring beans in Java, be aware that any bean that uses a database is going to be wrapped with a transactional wrapper.
				The transaction advice is handled in the transaction interceptor. When injecting dependencies, the transaction interceptor,
				not the actual Jetspeed service implementation, is injected as a dependency into other Jetpeed services.
	            </p>
			</subsection>
	        <subsection name="Declarative Transactions via Interception">
	            <p>
	            Lets take one example of a transaction Jetspeed service: the Permission Manager service. This service is configured in the <strong><code>security-managers.xml</code></strong> file.
	            The first bean is actually named with a <code>Impl</code> suffix. This is because this is the <strong>implementation</strong> bean:
	            the bean name <code>org.apache.jetspeed.security.impl.PermissionManagerImpl</code> is the same name as the class. Class attributes
	            represent the class name of the implementing class.
	            </p>
	            <p>
	            The second bean is named by interface: <code>org.apache.jetspeed.security.PermissionManager</code>. This bean is not the actual
	            Permission implementation. The bean definition is a transactional proxy: it is an bean wrapper or interceptor. When wiring the 
	            Permission Manager to another Jetspeed service, make sure to use the proxy object, not the actual implementation. This ensures
	            that declarative transaction support in Spring can intercept calls to the Permission Manager.
	            </p>
	            <p>Notice that the parent bean is <code>baseTransactionProxy</code>. This is how we get the transactional support: through Spring AOP 
	            inheriting the base functionality for proxying transactions declaratively. 
	            </p> 	            
	            <p>
<source><![CDATA[
  <!-- Security: Permission Manager -->
  <bean id="org.apache.jetspeed.security.impl.PermissionManagerImpl" 
  	   class="org.apache.jetspeed.security.impl.PermissionManagerImpl"  />
  
  <bean id="org.apache.jetspeed.security.PermissionManager" parent="baseTransactionProxy" 
		name="permissionManager" >
		<property name="proxyInterfaces">
			<value>org.apache.jetspeed.security.PermissionManager</value>
		</property>
		<property name="target">
			<ref bean="org.apache.jetspeed.security.impl.PermissionManagerImpl"/>
		</property>
		<property name="transactionAttributes">
			<props>				
				<prop key="remove*">PROPAGATION_REQUIRED</prop>
				<prop key="grant*">PROPAGATION_REQUIRED</prop>
				<prop key="revoke*">PROPAGATION_REQUIRED</prop>
				<prop key="grant*">PROPAGATION_REQUIRED</prop>
				<prop key="add*">PROPAGATION_REQUIRED</prop>
				<prop key="update*">PROPAGATION_REQUIRED</prop>
				<prop key="*">PROPAGATION_SUPPORTS</prop>
			</props>
		</property>
   </bean>
]]></source>	 
	            </p>
				<p>There are several transactional attributes that control the behavior of transactions on the wrappered bean</p>
				<ul>
					<li><b>proxyInterfaces</b> - the name of the interface to automatically proxy calls to. Only calls to this interface will be intercepted.
					This ensures that Jetspeed services only interact with each other along the interface contract of the Jetspeed API. 
					</li>
					<li><b>target</b> - the name of the bean being proxied for transactions. In this case its our Permission Manager implementation</li>
					<li><b>transactionalAttributes</b> - attributes that can control the behavior of methods on the proxied interface. Methods are listed
					as property keys and can contain wildcards such as all methods that start with <code>add*</code>. Then the body of the tag can contain
					either PROPAGATION_REQUIRED or PROPAGATION_SUPPORTS keywords, as well as exception handling behavior described below.
					</li>
				</ul>
				<p><b>Transaction Propagation Required</b> - If propagation is required, then the method is required to be a part of a transaction. If, when the method
				is called, there is not an active transaction, a transaction will be immediately started by the proxy (interceptor). Methods that store to a persistent database
				are usually marked as propagation required.
				</p>
				<p><b>Transaction Propagation Supported</b> - If propagation is only supported, then the method is NOT required to be a part of a transaction. If, when the method
				is called, there is not an active transaction, a transaction will be NOT be started by the proxy (interceptor). If there is a transaction active, the 
				method will join the transaction. Methods not marked with either required or supported properties will not participate in transactions.
				</p>
				<p><b>Exception Handling and Rollback</b> - 
				Transactions can also be committed or rolled back based on one or more Exception classes. In the example below
				we use <code>-</code>, the minus sign, to denote that any <code>RegistrationExceptions</code> that occur on any methods that start with <code>register*</code>
				will cause the transaction to <strong>rollback</strong>. On the contrary, using a <code>+</code>, a plus sign, will cause the transaction
				to commit for the given method and exception.
	
<source><![CDATA[				
        <property name="transactionAttributes">
            <props>
                <prop key="register*">PROPAGATION_REQUIRED,-org.apache.jetspeed.administration.RegistrationException</prop>
            </props>
        </property>
]]></source>	 
				</p>
			</subsection>
		    <subsection name="Nesting and Joining Transactions">
			<p> Transactions can be nested when one service calls another service. Take for example, the User Registration portlet which uses
			the Jetspeed Administration service method named <code>registerUser</code>. User registration requires transactional calls to
			both the Permission Manager and the User Manager. The transaction begins on the Jetspeed Administration service, calls into the
			Permission Manager to the grantPermission method, and then the User Manager's storeUser method. If any of these methods fails,
			the entire transaction is rolled back. If all methods succeed, the transaction is committed as shown below.</p>
	            <p>
					<img src="images/transaction-interception.jpg" border="0"/><br/><br/>	 
	            </p>
			</subsection>

        </section>
    </body>
</document>