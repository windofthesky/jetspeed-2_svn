<?xml version="1.0" ?>
<!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
    
    http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<document>
    <properties>
        <title>Jetspeed-2 RDBMS</title>
        <authors>
            <person name="David Le Strat" email="dlestrat@apache.org" />
        </authors>
    </properties>
    <body>
        <section name="Data Access Overview">
            <p>
            Jetspeed-2 RDBMS component provide some of level of abstraction from the underlying persistence mechanism.    
            </p>
            <subsection name="Data Access Using Object Relational Mapping">
            <p>
            Jetspeed-2 uses object relational mapping as the underlying technology for persistence.  By default, 
            <a href="http://db.apache.org/ojb/">Apache OJB</a> is used as an ORM engine.  In order to minimize Jetspeed-2
            OJB dependencies, the <code>InitablePersistenceBrokerDaoSupport</code> provides a layer of abstraction that minimizes
            the dependencies on a specific ORM engine.  The class diagram below illustration the Jetspeed-2 implementation classes
            that leverage <code>InitablePersistenceBrokerDaoSupport</code>:<br/>
            <img src="images/persistence-broker-dao-c.gif" border="0"/>
            </p>
            <p>
            The <code>InitablePersistenceBrokerDaoSupport</code> extends <code>org.springframework.orm.ojb.support.PersistenceBrokerDaoSupport</code>.
            </p>
            </subsection>
            <subsection name="Spring ORM Support">
            <p>
            Spring's adds significant support when using the O/R mapping layer of your choice to create data access applications.  The 
            <code>InitablePersistenceBrokerDaoSupport</code> extends spring layer of abstraction for persistence support, specifically the
            OJB <a href="http://static.springframework.org/spring/docs/1.2.x/reference/orm.html#orm-ojb"><code>PersistenceBroker</code> API support</a>.
            </p>
            <p>
            Using such a layer of abstraction has many advantages.  Some of the advantages outlined in Spring's documentation are:
            <ul>
            <li>Ease of testing. Spring's inversion of control approach makes it easy to swap the implementations and config locations of persistence manager instances,
            JDBC DataSources, transaction managers, and mapper object implementations (if needed). This makes it much easier to isolate and test each piece of
            persistence-related code in isolation.</li>
            <li>Common data access exceptions. Spring can wrap exceptions from you O/R mapping tool of choice, converting them from proprietary (potentially checked) exceptions
            to a common runtime DataAccessException hierarchy. This allows you to handle most persistence exceptions, which are non-recoverable, only in the appropriate layers,
            without annoying boilerplate catches/throws, and exception declarations. You can still trap and handle exceptions anywhere you need to. Remember that JDBC exceptions
            (including DB specific dialects) are also converted to the same hierarchy, meaning that you can perform some operations with JDBC within a consistent programming model.</li>
            <li>General resource management. Spring application contexts can handle the location and configuration of persistence managers instances, JDBC DataSources, 
            and other related resources. This makes these values easy to manage and change. Spring offers efficient, easy and safe handling of persistence resources.</li>
			<li>Integrated transaction management. Spring allows you to wrap your O/R mapping code with either a declarative, AOP style method interceptor,
			or an explicit 'template' wrapper class at the Java code level. In either case, transaction semantics are handled for you, and proper transaction handling (rollback, etc)
			in case of exceptions is taken care of. As discussed below, you also get the benefit of being able to use and swap various transaction managers, without your ORM specific code being affected:
			for example, between local transactions and JTA, with the same full services (such as declarative transactions) available in both scenarios. As an additional benefit,
			JDBC-related code can fully integrate transactionally with the code you use to do O/R mapping. This is useful for data access that's not suitable for O/R mapping,
			such as batch processing or streaming of BLOBs, which still needs to share common transactions with O/R mapping operations.</li>
			<li>To avoid vendor lock-in, and allow mix-and-match implementation strategies.</li>
			</ul>
			</p>
            </subsection>
        </section>
    </body>
</document>
